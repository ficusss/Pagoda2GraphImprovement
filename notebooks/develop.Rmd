---
title: "R Notebook"
output: html_notebook
---

###Подключаем требуемые пакеты

```{r, message=FALSE, warning=FALSE}

library(igraph)
library(pagoda2)
library(ggplot2)
# library(magrittr)
library(pbapply)

theme_set(theme_bw())

set.seed(2018)

```

### Считываем данные и строим граф

```{r}

path_floder <- DataPath("filtered_gene_bc_matrices/GRCh38")

load_matrix <- pagoda2::read.10x.matrices(path_floder)
load_matrix <- load_matrix[!duplicated(rownames(load_matrix)),]
pagoda_data <- pagoda2::basicP2proc(load_matrix)

```

### Выделяем вершины в кластерах и окрестностях кластеров, после чего строим граф для окрестности

```{r}

all_clusters <- pagoda_data$clusters$PCA$multilevel
clusters_name <- lapply(levels(all_clusters), ClusterNeighborhood, all_clusters, pagoda_data)

clusters_pagoda_data <- lapply(1:length(levels(all_clusters)), function(id) 
  GetPagoda(load_matrix[,clusters_name[[id]]$expand_cluster], embeding.type = NULL))

```

### Находим степень связности кластера с остальным графом

```{r}

vertex_connectivity <- lapply(clusters_name, GetDegreeConnectivity, graph=pagoda_data$graphs$PCA)

```

### Корректировка графа 

```{r}

corrected_graph_r <- UpdateGraph(all_clusters, clusters_pagoda_data,
                               pagoda_data$graphs$PCA, clusters.name = clusters_name,
                               vertex.connectivity = vertex_connectivity, deleted = FALSE)

```
```{r}

n_edges_per_vertex <- Matrix::rowSums(igraph::as_adj(corrected_graph_r$graphs$PCA))
qplot(n_edges_per_vertex, bins=50)
print(length(n_edges_per_vertex[n_edges_per_vertex == 0]))

```

```{r}

```


```{r}

update_knn_graph <- UpdateNNGraph(pagoda_data$graphs$PCA, clusters_pagoda_data,
                                   all_clusters, clusters_name, 15, graph.type = 'knn')

```


```{r}

GetBaseClusters_d <- function(base.pagoda.graph, new.graph, cluster.type) {
  l1 <- base.pagoda.graph$clusters$PCA[[1]]
  l2 <- new.graph[[1]]
  assertthat::are_equal(l1, l2)
  
  z <- base.pagoda.graph$clusters$PCA[[cluster.type]]
  names(z) <- names(base.pagoda.graph$clusters$PCA[[cluster.type]])
  
  base.clusters <- NA
  for (i in 1:length(z)) {
    curr.cell <- names(new.graph[[i]])
    base.clusters[i] <- z[curr.cell]
  }
  
  return(as.factor(base.clusters))
}

good_clusters_knn <- GetBaseClusters_d(pagoda_data, update_knn_graph, "multilevel")
good_clusters <- GetBaseClusters(pagoda_data, corrected_graph_r, "multilevel")

embeddings_pagoda <- EmbedGraph(pagoda_data$graphs$PCA, n.cores=2,
                                M=1, gamma=1.1, alpha=0.05, sgd_batches=1e8)
embeddings_corrected_graph_r <- EmbedGraph(corrected_graph_r$graphs$PCA, n.cores=2,
                                         M=1, gamma=1.1, alpha=0.05, sgd_batches=1e8)
embeddings_update_knn_graph <- EmbedGraph(update_knn_graph, n.cores=2,
                                         M=1, gamma=1.1, alpha=0.05, sgd_batches=1e8)

ggplot() + geom_point(
  aes(x = embeddings_pagoda[,1], y = embeddings_pagoda[,2], color=all_clusters),
  size=0.3, alpha=0.5)

ggplot() + geom_point(
  aes(x = embeddings_update_knn_graph[,1], y = embeddings_update_knn_graph[,2], color=good_clusters_knn),
  size=0.3, alpha=0.5)

ggplot() + geom_point(
  aes(x = embeddings_corrected_graph_r[,1], y = embeddings_corrected_graph_r[,2], color=good_clusters),
  size=0.3, alpha=0.5)

```


```{r}

n_edges_per_vertex <- Matrix::rowSums(igraph::as_adj(updated_knn_graph))
qplot(n_edges_per_vertex, bins=50)
print(length(n_edges_per_vertex[n_edges_per_vertex == 0]))

n_edges_per_vertex <- Matrix::rowSums(igraph::as_adj(updated_mnn_graph))
qplot(n_edges_per_vertex, bins=50)
print(length(n_edges_per_vertex[n_edges_per_vertex == 0]))

```

```{r}

ring_g <- igraph::make_ring(5)
star_g <- igraph::make_star(6, mode = "undirected", center = 6)
plot(star_g)
plot(ring_g)
union_g <- igraph::union(star_g, ring_g)
plot(union_g)
igraph::E(union_g)

correct_edge <- igraph::E(union_g)[1:8]
correct_edge

plot(igraph::subgraph.edges(union_g, correct_edge))

```