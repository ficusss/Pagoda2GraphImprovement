---
title: "R Notebook"
output: html_notebook
---

###Подключаем требуемые пакеты
```{r}

library(igraph)
library(pagoda2)
library(ggplot2)

```
###Считываем данные и строим граф
```{r}

path_floder <- paste0(getwd(), "/../data/filtered_gene_bc_matrices/GRCh38")

load_matrix <- pagoda2::read.10x.matrices(path_floder)
load_matrix <- load_matrix[!duplicated(rownames(load_matrix)),]
pagoda_data <- pagoda2::basicP2proc(load_matrix)

```
###Смотрим данные
```{r}

head(pagoda_data$reductions$PCA[,1:6], 5)

```
```{r}

correlation_matrix <- cor(t(pagoda_data$reductions$PCA))
head(correlation_matrix[,1:3], 5)

```
```{r}

plot_pagoda <- function(data, embedding_name, cluster_name=NULL, size=0.3, alpha=0.5) {
  
  embeddings <- data$embeddings$PCA[[embedding_name]]
  clusters <- data$clusters$PCA[[cluster_name]]
  
  ggplot() + 
    geom_point(aes(x = embeddings[,1], y = embeddings[,2], color=clusters),
               size=size,alpha=alpha)
}

plot_pagoda(pagoda_data, "largeVis", "infomap")
plot_pagoda(pagoda_data, "largeVis", "multilevel")
plot_pagoda(pagoda_data, "tSNE", "infomap")
plot_pagoda(pagoda_data, "tSNE", "multilevel")

```
Эта функция делает то же самое, что и basicP2proc, только более конфигурируема
```{r}

GetPagoda <- function (cm, n.cores = 30, clustering.type = "infomap", embeding.type = "tSNE", 
  tsne.iter.num = 1000, verbose = TRUE, n.pcs = 100, distance = "cosine", 
  trim = 5, n.odgenes = 1000,  ...) 
{
  r <- pagoda2::Pagoda2$new(cm, modelType = "plain", trim = trim, 
    n.cores = n.cores, verbose = verbose, ...)
  r$adjustVariance(plot = F, do.par = F, gam.k = 10, verbose = verbose)
  r$calculatePcaReduction(nPcs = n.pcs, n.odgenes = n.odgenes, maxit = 1000)

  r$makeKnnGraph(k = 30, type = "PCA", center = T, distance = "cosine", 
    weight.type = "none", verbose = verbose)
  if (clustering.type == "infomap") {
    r$getKnnClusters(method = igraph::infomap.community, type = "PCA", name = "infomap")
  } else if (clustering.type == "multilevel") {
    r$getKnnClusters(method = igraph::multilevel.community, type = "PCA", name = "multilevel")
  } else stop("Unknown clustering  type")

  if ("largeVis" %in% embeding.type) {
    r$getEmbedding(type = "PCA", embeddingType = "largeVis")
  }
  
  if ("tSNE" %in% embeding.type) {
    r$getEmbedding(type = "PCA", perplexity = 30, embeddingType = "tSNE", 
                   max_iter = tsne.iter.num)
  }

  return(r)
}

```
###Выделяем вершины в кластерах и окрестностях кластеров, после чего строим граф для окрестности
```{r}

all_clusters <- pagoda_data$clusters$PCA$multilevel

ClusterNeighborhood <- function(index, order=1, mindist=0) {
  tmp_list <- list()
  # выбираем кластер
  cluster <- names(all_clusters[all_clusters==index])
  # составляем список из всех соседей для каждой вершины кластера
  for (item in neighborhood(pagoda_data$graphs$PCA, nodes = cluster, 
                            order=order, mindist=mindist)) {
    # знаю что так делать медленно, но как по другому?
    tmp_list <- c(tmp_list, item)
  }
  # удаляем повторяющиеся вершины
  tmp_list <- names(tmp_list[!duplicated(tmp_list)])
  
  list(cluster=cluster, expand_cluster=tmp_list, add_vertex=tmp_list[!(tmp_list %in% cluster)])
}

clusters_name <- lapply(levels(all_clusters), ClusterNeighborhood)


CreateGraph <- function(index) {
  # pagoda2::basicP2proc(load_matrix[,clusters_name[[index]]$expand_cluster])
  GetPagoda(load_matrix[,clusters_name[[index]]$expand_cluster], embeding.type = NULL)
}

clusters_pagoda_data <- lapply(1:length(levels(all_clusters)), CreateGraph)

```
### Корректировка графа 
```{r}

UpdateGraph <- function(deleted=FALSE) {
  corrected_graph <- pagoda_data$graphs$PCA
  for (i in 1:length(levels(all_clusters))) {
    if (deleted == TRUE)
      corrected_graph <- delete_vertices(corrected_graph, clusters_name[[i]]$cluster)
    corrected_graph <- union(corrected_graph, clusters_pagoda_data[[i]]$graphs$PCA)
    # здесь должно сразу идти отсечение лишних связей
  }
  corrected_graph
}

corrected_graph <- GetPagoda(igraph::as_adj(UpdateGraph(deleted = FALSE)), embeding.type = NULL)
corrected_graph_d <- GetPagoda(igraph::as_adj(UpdateGraph(deleted = TRUE)), embeding.type = NULL)

```
###Отрировываем измененные графы
```{r}

EmbedGraph <- function(graph, M=1, gamma=1, alpha=0.1, sgd_batches=1e8,
                       seed=1, verbose=TRUE, n.cores=1) {
  wij <- igraph::as_adj(graph, attr='weight');
  coords <- largeVis::projectKNNs(wij = wij, dim=2, verbose = verbose,
                                  sgd_batches = sgd_batches,gamma=gamma, M=M,
                                  seed=seed, alpha=alpha, rho=1, threads=n.cores)
  colnames(coords) <- igraph::V(graph)$name
  return(t(coords))
}

```
```{r}

GetBaseClusters <- function(base_graph, new_graph, cluster_type) {
  l1 <- base_graph$clusters$PCA[[1]]
  l2 <- new_graph$clusters$PCA[[1]]
  assertthat::are_equal(l1, l2)
  
  z <- base_graph$clusters$PCA[[cluster_type]]
  names(z) <- names(base_graph$clusters$PCA[[cluster_type]])
  
  base_clusters <- NA
  for (i in 1:length(z)) {
    curr_cell <- names(new_graph$graphs$PCA[[i]])
    base_clusters[i] <- z[curr_cell]
  }
  as.factor(base_clusters)
}

good_clusters_d <- GetBaseClusters(pagoda_data, corrected_graph_d, "multilevel")
good_clusters <- GetBaseClusters(pagoda_data, corrected_graph, "multilevel")

```
```{r}
embeddings_pagoda <- EmbedGraph(pagoda_data$graphs$PCA, n.cores=2,
                                M=1, gamma=1.1, alpha=0.05, sgd_batches=1e7)
embeddings_corrected_graph <- EmbedGraph(corrected_graph$graphs$PCA, n.cores=2,
                                         M=1, gamma=1.1, alpha=0.05, sgd_batches=1e7)
embeddings_corrected_graph_d <- EmbedGraph(corrected_graph_d$graphs$PCA, n.cores=2,
                                           M=1, gamma=1.1, alpha=0.05, sgd_batches=1e7)

ggplot() + geom_point(
  aes(x = embeddings_pagoda[,1], y = embeddings_pagoda[,2],
      color=all_clusters),
  size=0.3, alpha=0.5)

ggplot() + geom_point(
  aes(x = embeddings_corrected_graph[,1], y = embeddings_corrected_graph[,2],
      color=good_clusters),
  size=0.3, alpha=0.5)

ggplot() + geom_point(
  aes(x = embeddings_corrected_graph_d[,1], y = embeddings_corrected_graph_d[,2],
      color=good_clusters_d),
  size=0.3, alpha=0.5)

```
```{r}

```
```{r}

```
```{r}
```
```{r}
```
### Зона тестирования функциональных возможностей RRRRrrrr...
```{r}

```
```{r}

```
```{r}

```